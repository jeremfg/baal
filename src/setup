#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
#
# This script is used to configure the Ba'al machine and developer environment
#
# Currently tested on Linux Mint (Ubuntu-based)

setup() {
  if ! setup_dependencies; then
    logError "Failed to setup dependencies"
    return 1
  fi

  if ! setup_host; then
    logError "Failed to setup host"
    return 1
  fi

  if ! setup_base_software; then
    logError "Failed to setup base software"
    return 1
  fi

  if ! setup_dev; then
    logError "Failed to setup developer environment"
    return 1
  fi

  if [[ ${REBOOT_REQUIRED} -eq 1 ]]; then
    logInfo "Rebooting..."
    shutdown -r now
  fi

  return 0
}

setup_dev() {
  logInfo "Setting up developer environment..."

  # Install git
  if ! pkg_install git; then
    logError "Failed to install git"
    return 1
  fi

  # Install python and pip
  if ! python_install; then
    logError "Failed to install python"
    return 1
  fi

  # Install nodejs to avoid nodeenv issues with pre-commit
  if ! pkg_install nodejs npm; then
    logError "Failed to install nodejs"
    return 1
  fi

  # Install pre-commit
  if ! pkg_install pre-commit; then
    logError "Failed to install pre-commit"
    return 1
  fi

  # Check if pre-commit is already installed
  if [[ ! -f "${BAAL_ROOT}/.git/hooks/pre-commit" ]]; then
    logInfo "Configuring pre-commit..."
    pushd "${BAAL_ROOT}" &>/dev/null || return 1
    if ! pre-commit install; then
      logError "Failed to configure pre-commit"
      return 1
    fi
    popd &>/dev/null || return 1
  fi

  # Install shellcheck
  if ! pkg_install shellcheck; then
    logError "Failed to install shellcheck"
    return 1
  fi

  # Install Docker Desktop
  if ! docker_install "${BAAL_ROOT}/.config/local.env"; then
    logError "Failed to install Docker Desktop"
    return 1
  fi

  # Install VS Code
  if ! vscode_install; then
    logError "Failed to install VS Code"
    return 1
  fi

  logInfo "Dev environment setup successfully"
  return 0
}

setup_dependencies() {
  # Make sure git is installed and configured
  if ! git_install; then
    logInfo "Failed to install git"
    return 1
  fi
  if ! git_configure "${BAAL_ROOT}"; then
    logInfo "Failed to configure git"
    return 1
  fi

  # Install and configure encryption tools
  if ! sops_install; then
    logInfo "Failed to install sops"
    return 1
  fi
  if ! age_install; then
    logInfo "Failed to install age"
    return 1
  fi
  if ! age_configure "${AGE_KEY}"; then
    logInfo "Failed to configure age"
    return 1
  fi

  return 0
}

setup_base_software() {
  # Install Librewolf
  if ! librewolf_install; then
    logError "Failed to install Librewolf"
    return 1
  fi

  # Configure Librewolf for multi-profiles and Firefox Sync
  if ! librewolf_configure; then
    logError "Failed to configure Librewolf"
    return 1
  fi

  # Install Android development tools
  if ! android_install; then
    logError "Failed to install Android development tools"
    return 1
  fi

  # # Install baal tools globally
  # if ! install_tools; then
  #   logError "Failed to install baal tools"
  #   return 1
  # fi

  return 0
}

setup_host() {
  if ! config_load "${BAAL_ROOT}/.config/local.env"; then
    logError "Failed to load local configuration"
    return 1
  elif ! check_system; then
    logError "This script is not supported on this system"
    return 1
  elif [[ -z "${BAAL_NAME}" ]]; then
    logError "BAAL_NAME is not set"
    return 1
  elif ! hostname_configure "${BAAL_NAME}"; then
    logError "Failed to configure hostname"
    return 1
  fi

  # Mount local drives
  if ! mount_tb_nvme0n1p1; then
    logError "Failed to mount TB drive"
    return 1
  fi

  # Mount network drives
  if ! mount_network_drives; then
    logError "Failed to mount network drives"
    return 1
  fi

  # Add additional host configuration here

  return 0
}

mount_tb_nvme0n1p1() {
  local device="/dev/nvme0n1p1"
  local mount_point="/mnt/tb"
  local uuid fs_type
  local desired_fstab_entry
  local current_fstab_entry
  local is_mounted=0

  # Check device exists
  if [[ ! -b ${device} ]]; then
    logWarn "Device ${device} not found, skipping"
    return 0
  fi

  logInfo "Configuring ${device} to mount at ${mount_point}"

  # Create mount point
  if [[ ! -d ${mount_point} ]]; then
    if ! sudo mkdir -p "${mount_point}"; then
      logError "Failed to create mount point ${mount_point}"
      return 1
    fi
  fi

  # Get UUID and filesystem type
  uuid=$(sudo blkid -s UUID -o value "${device}")
  fs_type=$(sudo blkid -s TYPE -o value "${device}")
  if [[ -z ${uuid} ]]; then
    logError "Failed to get UUID of ${device}"
    return 1
  fi
  if [[ -z ${fs_type} ]]; then
    logError "Failed to get filesystem type of ${device}"
    return 1
  fi

  # Get current user info
  local uid gid
  uid=$(id -u "${SUDO_USER:-${USER}}")
  gid=$(id -g "${SUDO_USER:-${USER}}")

  # Desired fstab entry
  local mount_opts passno
  case "${fs_type}" in
  ext4)
    mount_opts="defaults"
    passno=2
    ;;
  *)
    logError "Unsupported filesystem type for ${device}: ${fs_type}"
    return 1
    ;;
  esac

  desired_fstab_entry="UUID=${uuid} ${mount_point} ${fs_type} ${mount_opts} 0 ${passno}"

  # Check if already mounted
  if mountpoint -q "${mount_point}"; then
    is_mounted=1
  fi

  # Read current fstab entry for this mount point (if any)
  current_fstab_entry=$(sudo awk -v mp="${mount_point}" '$2 == mp {print}' /etc/fstab || true)
  current_fstab_entry=$(echo "${current_fstab_entry}" | tail -n 1)

  # Update fstab if needed
  if [[ "${current_fstab_entry}" != "${desired_fstab_entry}" ]]; then
    # Remove any previous entry for the mount point in fstab
    sudo sed -i "\|[[:space:]]${mount_point}[[:space:]]|d" /etc/fstab
    echo "${desired_fstab_entry}" | sudo tee -a /etc/fstab >/dev/null
    logInfo "Updated fstab entry for ${mount_point}"

    # Remount if it was already mounted
    if [[ ${is_mounted} -eq 1 ]]; then
      if ! sudo umount "${mount_point}"; then
        logError "Failed to unmount ${mount_point} for remount"
        return 1
      else
        is_mounted=0
      fi
    fi
  fi

  # Mount if not mounted
  if [[ ${is_mounted} -eq 0 ]]; then
    if ! sudo mount "${mount_point}"; then
      logError "Failed to mount ${mount_point}"
      return 1
    fi
  fi

  # Set ownership
  if ! sudo chown "${SUDO_USER:-${USER}}:${SUDO_USER:-${USER}}" "${mount_point}"; then
    logError "Failed to set ownership of ${mount_point}"
    return 1
  fi

  logInfo "Partition ${device} mounted at ${mount_point}"
  return 0
}

mount_network_drives() {
  logInfo "Configuring network drives..."

  # shellcheck disable=SC2154 # SMB_PASSWORD is loaded via config_load
  add_or_update_smb_mount "//nas.sonia.jeremfg.com/Data/Group/Family" "/mnt/Sonia-Family" "Jeremie" "${SMB_PASSWORD}" "SOL"
  add_or_update_smb_mount "//nas.sonia.jeremfg.com/Data/Public" "/mnt/Sonia-Public" "Jeremie" "${SMB_PASSWORD}" "SOL"
  add_or_update_smb_mount "//nas.sonia.jeremfg.com/Data/Vault/DemersUsers/Jeremie" "/mnt/Sonia-JeremieBackup" "Jeremie" "${SMB_PASSWORD}" "SOL"

  add_or_update_smb_mount "//halley.demers.jeremfg.com/User/Jeremie" "/mnt/Demers-Jeremie" "Jeremie" "${SMB_PASSWORD}" "SOL"
  add_or_update_smb_mount "//halley.demers.jeremfg.com/Group/Family" "/mnt/Demers-Family" "Jeremie" "${SMB_PASSWORD}" "SOL"
  add_or_update_smb_mount "//halley.demers.jeremfg.com/Public" "/mnt/Demers-Public" "Jeremie" "${SMB_PASSWORD}" "SOL"

  sudo systemctl daemon-reload
  if ! sudo mount -a; then
    logWarn "Some network mounts may have failed"
  fi

  logInfo "Network drives configured"
  return 0
}

add_or_update_smb_mount() {
  local remote_path="$1"
  local mount_point="$2"
  local username="$3"
  local password="$4"
  local domain="$5"
  local options uid gid

  # Validation
  if [[ -z "${remote_path}" || -z "${mount_point}" || -z "${username}" || -z "${password}" ]]; then
    logError "Missing parameters for SMB mount: ${remote_path}"
    return 1
  fi

  # Create mount point
  if [[ ! -d "${mount_point}" ]]; then
    logInfo "Creating mount point: ${mount_point}"
    if ! sudo mkdir -p "${mount_point}"; then
      logError "Failed to create mount point ${mount_point}"
      return 1
    fi
    sudo chown "${SUDO_USER:-${USER}}:${SUDO_USER:-${USER}}" "${mount_point}"
  fi

  # Build mount options
  uid=$(id -u "${SUDO_USER:-${USER}}")
  gid=$(id -g "${SUDO_USER:-${USER}}")
  options="username=${username},password=${password}"
  [[ -n "${domain}" ]] && options+=",domain=${domain}"
  options+=",iocharset=utf8,uid=${uid},gid=${gid},nofail,x-systemd.automount"

  local fstab_entry="${remote_path} ${mount_point} cifs ${options} 0 0"

  # Remove old entries
  if sudo grep -qE "^[[:space:]]*//.*[[:space:]]+${mount_point}[[:space:]]+cifs" /etc/fstab; then
    logTrace "Cleaning old entries for ${mount_point}"
    sudo sed -i "\|//.* ${mount_point} cifs .*|d" /etc/fstab
  fi

  logTrace "Adding fstab entry for ${mount_point}"
  echo "${fstab_entry}" | sudo tee -a /etc/fstab >/dev/null

  return 0
}

check_system() {
  local name
  if [[ -z "${BAAL_MOTHERBOARD}" ]]; then
    logError "BAAL_MOTHERBOARD is not set"
    return 1
  fi

  if id_identify name; then
    if [[ "${name}" == "${BAAL_MOTHERBOARD}" ]]; then
      return 0
    fi
  fi

  return 1
}

install_tools() {
  logInfo "Installing baal tools to ${PREFIX}/bin..."

  # Ensure bin directory exists
  if [[ ! -d "${PREFIX}/bin" ]]; then
    logInfo "Creating ${PREFIX}/bin"
    mkdir -p "${PREFIX}/bin"
  fi

  # Install all executable scripts from tool/
  local tool_dir="${BAAL_ROOT}/tool"
  local installed=0
  local failed=0

  for script in "${tool_dir}"/*; do
    if [[ -f "${script}" && -x "${script}" ]]; then
      local script_name
      script_name=$(basename "${script}")
      local target="${PREFIX}/bin/${script_name}"

      logTrace "Installing ${script_name} to ${target}"
      if ln -sf "${script}" "${target}"; then
        ((installed++))
      else
        logError "Failed to install ${script_name}"
        ((failed++))
      fi
    fi
  done

  logInfo "Installed ${installed} tools to ${PREFIX}/bin"

  if [[ ${failed} -gt 0 ]]; then
    logError "Failed to install ${failed} tools"
    return 1
  fi

  # Ensure PREFIX/bin is in PATH
  if [[ ":${PATH}:" != *":${PREFIX}/bin:"* ]]; then
    logWarn "${PREFIX}/bin is not in PATH. Add it to your shell profile:"
    logWarn "  export PATH=\"${PREFIX}/bin:\${PATH}\""
  fi

  return 0
}

external_depends() {
  # Make sure bpkg is installed for managing bash dependencies
  if ! command -v bpkg &>/dev/null; then
    # shellcheck disable=SC2312 # Piping curl to bash is intentional for bpkg installation
    if ! curl -sLo- https://get.bpkg.sh | bash; then
      echo "Failed to install bpkg"
      return 1
    fi
  fi

  # Determine BPKG's global prefix
  if [[ -z "${PREFIX}" ]]; then
    if [[ $(id -u || true) -eq 0 ]]; then
      PREFIX="/usr/local"
    else
      PREFIX="${HOME}/.local"
    fi
  fi

  if [[ ! -f "${PREFIX}/lib/slf4.sh" ]]; then
    if ! bpkg install -g jeremfg/slf4.sh; then
      echo "Failed to install slf4.sh"
      return 1
    fi
  fi

  if [[ ! -f "${PREFIX}/lib/config.sh" ]]; then
    if ! bpkg install -g jeremfg/config.sh; then
      echo "Failed to install config.sh"
      return 1
    fi
  fi

  # shellcheck disable=SC1091 # Library paths are dynamically determined at runtime
  if ! source "${PREFIX}/lib/slf4.sh"; then
    echo "Failed to import slf4.sh"
    exit 1
  elif ! source "${PREFIX}/lib/config.sh"; then
    logFatal "Failed to import config.sh"
  fi
}

internal_depends() {
  # shellcheck disable=SC1091 # Internal setup scripts are in a runtime-determined path
  if ! config_load "${BAAL_ROOT}/.config/local.env"; then
    logFatal "Failed to load local.env"
  elif [[ -z "${SETUP_DIR}" ]]; then
    logFatal "SETUP_DIR is not set"
  elif ! source "${SETUP_DIR}/src/git.sh"; then
    logFatal "Failed to import git.sh"
  elif ! source "${SETUP_DIR}/src/sops.sh"; then
    logFatal "Failed to import sops.sh"
  elif ! source "${SETUP_DIR}/src/age.sh"; then
    logFatal "Failed to import age.sh"
  elif ! source "${SETUP_DIR}/src/hostname.sh"; then
    logFatal "Failed to import hostname.sh"
  elif ! source "${SETUP_DIR}/src/identity.sh"; then
    logFatal "Failed to import identity"
  elif ! source "${SETUP_DIR}/src/pkg.sh"; then
    logFatal "Failed to import pkg.sh"
  elif ! source "${SETUP_DIR}/src/extrepo.sh"; then
    logFatal "Failed to import extrepo.sh"
  elif ! source "${SETUP_DIR}/src/python.sh"; then
    logFatal "Failed to import python.sh"
  elif ! source "${SETUP_DIR}/src/docker.sh"; then
    logFatal "Failed to import docker.sh"
  elif ! source "${SETUP_DIR}/src/android.sh"; then
    logFatal "Failed to import android.sh"
  elif ! source "${SETUP_DIR}/src/vscode.sh"; then
    logFatal "Failed to import vscode.sh"
  elif ! source "${SETUP_DIR}/src/librewolf.sh"; then
    logFatal "Failed to import librewolf.sh"
  fi
}

# Variables loaded externally
if [[ -z "${LEVEL_ALL}" ]]; then LEVEL_ALL=""; fi

# Constants
AGE_KEY="baal"
REBOOT_REQUIRED=0

###########################
###### Startup logic ######
###########################

# Get directory of this script
# https://stackoverflow.com/a/246128
BAAL_SOURCE=${BASH_SOURCE[0]}
while [[ -L "${BAAL_SOURCE}" ]]; do # resolve $BAAL_SOURCE until the file is no longer a symlink
  BAAL_ROOT=$(cd -P "$(dirname "${BAAL_SOURCE}")" >/dev/null 2>&1 && pwd)
  BAAL_SOURCE=$(readlink "${BAAL_SOURCE}")
  [[ ${BAAL_SOURCE} != /* ]] && BAAL_SOURCE=${BAAL_ROOT}/${BAAL_SOURCE} # if $BAAL_SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
BAAL_ROOT=$(cd -P "$(dirname "${BAAL_SOURCE}")" >/dev/null 2>&1 && pwd)
BAAL_ROOT=$(realpath "${BAAL_ROOT}/..")

# Configure logger
export LOG_CONSOLE=1
export LOG_LEVEL=0

# Install external dependencies
if ! external_depends; then
  exit 1
elif ! internal_depends; then
  logFatal "Failed to load internal dependencies"
fi

if [[ -p /dev/stdin ]] && [[ -z ${BASH_SOURCE[0]} ]]; then
  # This script was piped
  logFatal "This script cannot be piped"
elif [[ ${BASH_SOURCE[0]} != "${0}" ]]; then
  # This script was sourced
  logFatal "This script cannot be sourced"
else
  # This script was executed
  setup "${@}"
  exit $?
fi
